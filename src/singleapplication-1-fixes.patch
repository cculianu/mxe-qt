From d9fdc9b25a91beb94d9280c5fcacc9856d9528e2 Mon Sep 17 00:00:00 2001
From: Jonas Kvinge <jonas@jkvinge.net>
Date: Wed, 4 Mar 2020 23:44:03 +0100
Subject: [PATCH] Build SingleApplication as a library using CMake

---
 CMakeLists.txt                                | 89 +++++++++++-------
 Version.cmake                                 | 94 +++++++++++++++++++
 singleapplication.cpp                         | 21 ++---
 singleapplication.h => singleapplication.h.in | 18 ++--
 singleapplication.pc.cmake                    | 10 ++
 singleapplication_p.cpp                       | 31 +++---
 ...pplication_p.h => singleapplication_p.h.in | 10 +-
 7 files changed, 197 insertions(+), 76 deletions(-)
 create mode 100644 Version.cmake
 rename singleapplication.h => singleapplication.h.in (90%)
 create mode 100644 singleapplication.pc.cmake
 rename singleapplication_p.h => singleapplication_p.h.in (92%)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index d619230..e4eebe2 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,43 +1,64 @@
-cmake_minimum_required(VERSION 3.1.0)
+cmake_minimum_required(VERSION 2.8.11)
+set(CMAKE_CXX_STANDARD 11)
 
-project(SingleApplication)
+include(Version.cmake)
 
-set(CMAKE_INCLUDE_CURRENT_DIR ON)
-set(CMAKE_AUTOMOC ON)
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} --std=c++11 -U__STRICT_ANSI__ -Wall -Wextra -Wpedantic -Woverloaded-virtual -fpermissive")
 
-# SingleApplication base class
-set(QAPPLICATION_CLASS QCoreApplication CACHE STRING "Inheritance class for SingleApplication")
-set_property(CACHE QAPPLICATION_CLASS PROPERTY STRINGS QApplication QGuiApplication QCoreApplication)
+#option(BUILD_SHARED_LIBS "Build shared library" ON)
 
-# Libary target
-add_library(${PROJECT_NAME} STATIC
-    singleapplication.cpp
-    singleapplication_p.cpp
-    )
-
-# Find dependencies
-find_package(Qt5Network)
-if(QAPPLICATION_CLASS STREQUAL QApplication)
-    find_package(Qt5 COMPONENTS Widgets REQUIRED)
-elseif(QAPPLICATION_CLASS STREQUAL QGuiApplication)
-    find_package(Qt5 COMPONENTS Gui REQUIRED)
-else()
-    find_package(Qt5 COMPONENTS Core REQUIRED)
+if(NOT QAPPLICATION_CLASS)
+  set(QAPPLICATION_CLASS "QApplication")
 endif()
-add_compile_definitions(QAPPLICATION_CLASS=${QAPPLICATION_CLASS})
-
-# Link dependencies
-target_link_libraries(${PROJECT_NAME} PRIVATE Qt5::Network)
-if(QAPPLICATION_CLASS STREQUAL QApplication)
-    target_link_libraries(${PROJECT_NAME} PRIVATE Qt5::Widgets)
-elseif(QAPPLICATION_CLASS STREQUAL QGuiApplication)
-    target_link_libraries(${PROJECT_NAME} PRIVATE Qt5::Gui)
+
+if (QAPPLICATION_CLASS STREQUAL "QApplication")
+  set(SINGLEAPPLICATION_NAME "singleapplication")
+  set(SINGLEAPPLICATION_CLASS "SingleApplication")
+elseif (QAPPLICATION_CLASS STREQUAL "QCoreApplication")
+  set(SINGLEAPPLICATION_NAME "singlecoreapplication")
+  set(SINGLEAPPLICATION_CLASS "SingleCoreApplication")
+elseif (QAPPLICATION_CLASS STREQUAL "QGuiApplication")
+  set(SINGLEAPPLICATION_NAME "singleguiapplication")
+  set(SINGLEAPPLICATION_CLASS "SingleGuiApplication")
 else()
-    target_link_libraries(${PROJECT_NAME} PRIVATE Qt5::Core)
+  message(FATAL_ERROR "Application class must be QApplication, QCoreApplication or QGuiApplication")
 endif()
 
-if(WIN32)
-    target_link_libraries(${PROJECT_NAME} PRIVATE advapi32)
-endif()
+project(${SINGLEAPPLICATION_NAME})
+
+set(LIB_SUFFIX "" CACHE STRING "Define suffix of directory name (32/64)")
+set(BIN_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/bin" CACHE PATH "The subdirectory to the binaries prefix (default prefix/bin)")
+set(LIB_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/lib${LIB_SUFFIX}" CACHE PATH "The subdirectory relative to the install prefix where libraries will be installed (default is /lib${LIB_SUFFIX})")
+set(INCLUDE_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/include" CACHE PATH "The subdirectory to the header prefix")
+
+include_directories(${CMAKE_CURRENT_SOURCE_DIR})
+include_directories(${CMAKE_CURRENT_BINARY_DIR})
+configure_file("${CMAKE_CURRENT_SOURCE_DIR}/singleapplication.h.in" "${CMAKE_CURRENT_BINARY_DIR}/${SINGLEAPPLICATION_NAME}.h" @ONLY)
+configure_file("${CMAKE_CURRENT_SOURCE_DIR}/singleapplication_p.h.in" "${CMAKE_CURRENT_BINARY_DIR}/singleapplication_p.h" @ONLY)
+configure_file("${CMAKE_CURRENT_SOURCE_DIR}/singleapplication.pc.cmake" "${CMAKE_CURRENT_BINARY_DIR}/${SINGLEAPPLICATION_NAME}.pc" @ONLY)
+
+set(QT_MIN_VERSION 5.5)
+find_package(Qt5 ${QT_MIN_VERSION} REQUIRED COMPONENTS Core Widgets Network)
+
+set(SINGLEAPP-SOURCES singleapplication.cpp singleapplication_p.cpp)
+set(SINGLEAPP-MOC-HEADERS ${CMAKE_CURRENT_BINARY_DIR}/${SINGLEAPPLICATION_NAME}.h ${CMAKE_CURRENT_BINARY_DIR}/singleapplication_p.h)
+QT5_WRAP_CPP(SINGLEAPP-SOURCES-MOC ${SINGLEAPP-MOC-HEADERS})
+add_library(${SINGLEAPPLICATION_NAME} ${SINGLEAPP-SOURCES} ${SINGLEAPP-SOURCES-MOC})
+target_link_libraries(${SINGLEAPPLICATION_NAME} Qt5::Core Qt5::Widgets Qt5::Network)
+
+install(FILES "${CMAKE_CURRENT_BINARY_DIR}/${SINGLEAPPLICATION_NAME}.pc" DESTINATION "${LIB_INSTALL_DIR}/pkgconfig")
+
+set_target_properties(${SINGLEAPPLICATION_NAME} PROPERTIES
+  VERSION ${SINGLEAPPLICATION_SOVERSION_MAJOR}.${SINGLEAPPLICATION_SOVERSION_MINOR}.${SINGLEAPPLICATION_SOVERSION_PATCH}
+  SOVERSION ${SINGLEAPPLICATION_SOVERSION_MAJOR}
+  INSTALL_NAME_DIR ${LIB_INSTALL_DIR}
+  DEFINE_SYMBOL MAKE_SINGLEAPPLICATION_LIB
+  LINK_INTERFACE_LIBRARIES ""
+  PUBLIC_HEADER "${CMAKE_CURRENT_BINARY_DIR}/${SINGLEAPPLICATION_NAME}.h"
+)
 
-target_include_directories(${PROJECT_NAME} PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
+install(TARGETS ${SINGLEAPPLICATION_NAME}
+  LIBRARY DESTINATION ${LIB_INSTALL_DIR}
+  PUBLIC_HEADER DESTINATION ${INCLUDE_INSTALL_DIR}
+)
diff --git a/Version.cmake b/Version.cmake
new file mode 100644
index 0000000..cb83118
--- /dev/null
+++ b/Version.cmake
@@ -0,0 +1,94 @@
+set(SINGLEAPPLICATION_VERSION_MAJOR 3)
+set(SINGLEAPPLICATION_VERSION_MINOR 0)
+set(SINGLEAPPLICATION_VERSION_PATCH 13)
+#set(SINGLEAPPLICATION_VERSION_PRERELEASE rc1)
+
+set(INCLUDE_GIT_REVISION ON)
+
+# 1. If the library source code has changed at all since the last update, then increment revision.
+# 2. If any interfaces have been added, removed, or changed since the last update, increment current, and set revision to 0.
+# 3. If any interfaces have been added since the last public release, then increment age.
+# 4. If any interfaces have been removed since the last public release, then set age to 0.
+set(SINGLEAPPLICATION_SOVERSION_CURRENT  0)
+set(SINGLEAPPLICATION_SOVERSION_REVISION 0)
+set(SINGLEAPPLICATION_SOVERSION_AGE      0)
+
+
+set(majorminorpatch "${SINGLEAPPLICATION_VERSION_MAJOR}.${SINGLEAPPLICATION_VERSION_MINOR}.${SINGLEAPPLICATION_VERSION_PATCH}")
+
+set(SINGLEAPPLICATION_VERSION_DISPLAY "${majorminorpatch}")
+set(SINGLEAPPLICATION_VERSION_PACKAGE "${majorminorpatch}")
+
+if(${SINGLEAPPLICATION_VERSION_PATCH} EQUAL "0")
+  set(SINGLEAPPLICATION_VERSION_DISPLAY "${SINGLEAPPLICATION_VERSION_MAJOR}.${SINGLEAPPLICATION_VERSION_MINOR}")
+endif(${SINGLEAPPLICATION_VERSION_PATCH} EQUAL "0")
+
+if(SINGLEAPPLICATION_VERSION_PRERELEASE)
+  set(SINGLEAPPLICATION_VERSION_DISPLAY "${SINGLEAPPLICATION_VERSION_DISPLAY} ${SINGLEAPPLICATION_VERSION_PRERELEASE}")
+  set(SINGLEAPPLICATION_VERSION_RPM_R   "0.${SINGLEAPPLICATION_VERSION_PRERELEASE}")
+  set(SINGLEAPPLICATION_VERSION_PACKAGE "${SINGLEAPPLICATION_VERSION_PACKAGE}${SINGLEAPPLICATION_VERSION_PRERELEASE}")
+endif(SINGLEAPPLICATION_VERSION_PRERELEASE)
+
+math(EXPR SINGLEAPPLICATION_SOVERSION_MAJOR "${SINGLEAPPLICATION_SOVERSION_CURRENT} - ${SINGLEAPPLICATION_SOVERSION_AGE}")
+math(EXPR SINGLEAPPLICATION_SOVERSION_MINOR "${SINGLEAPPLICATION_SOVERSION_AGE}")
+math(EXPR SINGLEAPPLICATION_SOVERSION_PATCH "${SINGLEAPPLICATION_SOVERSION_REVISION}")
+
+if(INCLUDE_GIT_REVISION AND EXISTS "${CMAKE_SOURCE_DIR}/.git")
+
+  find_program(GIT_EXECUTABLE git)
+  if(NOT GIT_EXECUTABLE OR GIT_EXECUTABLE-NOTFOUND)
+    message(FATAL_ERROR "Missing GIT executable." )
+  endif()
+
+  # Get the current working branch
+  execute_process(
+    COMMAND ${GIT_EXECUTABLE} rev-parse --abbrev-ref HEAD
+    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
+    RESULT_VARIABLE GIT_CMD_RESULT_BRANCH
+    OUTPUT_VARIABLE GIT_BRANCH
+    OUTPUT_STRIP_TRAILING_WHITESPACE
+    ERROR_QUIET
+  )
+  # Get the latest abbreviated commit hash of the working branch
+  execute_process(
+    COMMAND ${GIT_EXECUTABLE} describe --long --tags --always
+    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
+    RESULT_VARIABLE GIT_CMD_RESULT_REVISION
+    OUTPUT_VARIABLE GIT_REVISION
+    OUTPUT_STRIP_TRAILING_WHITESPACE
+    ERROR_QUIET
+  )
+
+  if(NOT ${GIT_CMD_RESULT_REVISION} EQUAL 0)
+    message(FATAL_ERROR "GIT command failed to get revision string '${GIT_REVISION}'")
+  endif()
+
+endif()
+
+if(FORCE_GIT_REVISION)
+  set(GIT_REVISION ${FORCE_GIT_REVISION})
+endif()
+
+if(GIT_REVISION)
+
+  string(REGEX REPLACE "^(.+)-([0-9]+)-(g[a-f0-9]+)$" "\\1;\\2;\\3" GIT_PARTS ${GIT_REVISION})
+
+  if(NOT GIT_PARTS)
+    message(FATAL_ERROR "Failed to parse git revision string '${GIT_REVISION}'")
+  endif()
+
+  list(LENGTH GIT_PARTS GIT_PARTS_LENGTH)
+  if(NOT GIT_PARTS_LENGTH EQUAL 3)
+    message(FATAL_ERROR "Failed to parse git revision string '${GIT_REVISION}'")
+  endif()
+
+  list(GET GIT_PARTS 0 GIT_TAGNAME)
+  list(GET GIT_PARTS 1 GIT_COMMITCOUNT)
+  list(GET GIT_PARTS 2 GIT_SHA1)
+
+  set(HAS_GIT_REVISION ON)
+
+  set(SINGLEAPPLICATION_VERSION_DISPLAY "${GIT_REVISION}")
+  set(SINGLEAPPLICATION_VERSION_PACKAGE "${GIT_TAGNAME}.${GIT_COMMITCOUNT}.${GIT_SHA1}")
+
+endif()
diff --git a/singleapplication.cpp b/singleapplication.cpp
index 26e4ca2..63def0f 100644
--- a/singleapplication.cpp
+++ b/singleapplication.cpp
@@ -30,7 +30,6 @@
 #include <QtCore/QDateTime>
 #endif
 
-#include "singleapplication.h"
 #include "singleapplication_p.h"
 
 /**
@@ -40,7 +39,7 @@
  * @param argv
  * @param {bool} allowSecondaryInstances
  */
-SingleApplication::SingleApplication( int &argc, char *argv[], bool allowSecondary, Options options, int timeout )
+SINGLEAPPLICATION_CLASS::SINGLEAPPLICATION_CLASS( int &argc, char *argv[], bool allowSecondary, Options options, int timeout )
     : app_t( argc, argv ), d_ptr( new SingleApplicationPrivate( this ) )
 {
     Q_D(SingleApplication);
@@ -78,7 +77,7 @@ SingleApplication::SingleApplication( int &argc, char *argv[], bool allowSeconda
     } else {
         // Attempt to attach to the memory segment
         if( ! d->memory->attach() ) {
-            qCritical() << "SingleApplication: Unable to attach to shared memory block.";
+            qCritical() << QString(QT_STRINGIFY(SINGLEAPPLICATION_CLASS)) + ":" << "Unable to attach to shared memory block.";
             qCritical() << d->memory->errorString();
             delete d;
             ::exit( EXIT_FAILURE );
@@ -96,7 +95,7 @@ SingleApplication::SingleApplication( int &argc, char *argv[], bool allowSeconda
         if( d->blockChecksum() == inst->checksum ) break;
 
         if( time.elapsed() > 5000 ) {
-            qWarning() << "SingleApplication: Shared memory block has been in an inconsistent state from more than 5s. Assuming primary instance failure.";
+            qWarning() << QString(QT_STRINGIFY(SINGLEAPPLICATION_CLASS)) + ":" << "Shared memory block has been in an inconsistent state from more than 5s. Assuming primary instance failure.";
             d->initializeMemoryBlock();
         }
 
@@ -142,43 +141,43 @@ SingleApplication::SingleApplication( int &argc, char *argv[], bool allowSeconda
 /**
  * @brief Destructor
  */
-SingleApplication::~SingleApplication()
+SINGLEAPPLICATION_CLASS::~SINGLEAPPLICATION_CLASS()
 {
     Q_D(SingleApplication);
     delete d;
 }
 
-bool SingleApplication::isPrimary()
+bool SINGLEAPPLICATION_CLASS::isPrimary()
 {
     Q_D(SingleApplication);
     return d->server != nullptr;
 }
 
-bool SingleApplication::isSecondary()
+bool SINGLEAPPLICATION_CLASS::isSecondary()
 {
     Q_D(SingleApplication);
     return d->server == nullptr;
 }
 
-quint32 SingleApplication::instanceId()
+quint32 SINGLEAPPLICATION_CLASS::instanceId()
 {
     Q_D(SingleApplication);
     return d->instanceNumber;
 }
 
-qint64 SingleApplication::primaryPid()
+qint64 SINGLEAPPLICATION_CLASS::primaryPid()
 {
     Q_D(SingleApplication);
     return d->primaryPid();
 }
 
-QString SingleApplication::primaryUser()
+QString SINGLEAPPLICATION_CLASS::primaryUser()
 {
     Q_D(SingleApplication);
     return d->primaryUser();
 }
 
-bool SingleApplication::sendMessage( QByteArray message, int timeout )
+bool SINGLEAPPLICATION_CLASS::sendMessage( QByteArray message, int timeout )
 {
     Q_D(SingleApplication);
 
diff --git a/singleapplication.h b/singleapplication.h.in
similarity index 90%
rename from singleapplication.h
rename to singleapplication.h.in
index f91e3a2..1896cd9 100644
--- a/singleapplication.h
+++ b/singleapplication.h.in
@@ -20,15 +20,13 @@
 // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 // THE SOFTWARE.
 
-#ifndef SINGLE_APPLICATION_H
-#define SINGLE_APPLICATION_H
+#ifndef @SINGLEAPPLICATION_CLASS@
 
 #include <QtCore/QtGlobal>
 #include <QtNetwork/QLocalSocket>
 
-#ifndef QAPPLICATION_CLASS
-  #define QAPPLICATION_CLASS QCoreApplication
-#endif
+#define QAPPLICATION_CLASS @QAPPLICATION_CLASS@
+#define SINGLEAPPLICATION_CLASS @SINGLEAPPLICATION_CLASS@
 
 #include QT_STRINGIFY(QAPPLICATION_CLASS)
 
@@ -39,7 +37,7 @@ class SingleApplicationPrivate;
  * Application
  * @see QCoreApplication
  */
-class SingleApplication : public QAPPLICATION_CLASS
+class SINGLEAPPLICATION_CLASS : public QAPPLICATION_CLASS
 {
     Q_OBJECT
 
@@ -85,8 +83,8 @@ class SingleApplication : public QAPPLICATION_CLASS
      * Usually 4*timeout would be the worst case (fail) scenario.
      * @see See the corresponding QAPPLICATION_CLASS constructor for reference
      */
-    explicit SingleApplication( int &argc, char *argv[], bool allowSecondary = false, Options options = Mode::User, int timeout = 1000 );
-    ~SingleApplication();
+    explicit SINGLEAPPLICATION_CLASS( int &argc, char *argv[], bool allowSecondary = false, Options options = Mode::User, int timeout = 1000 );
+    ~SINGLEAPPLICATION_CLASS();
 
     /**
      * @brief Returns if the instance is the primary instance
@@ -136,6 +134,6 @@ class SingleApplication : public QAPPLICATION_CLASS
     Q_DECLARE_PRIVATE(SingleApplication)
 };
 
-Q_DECLARE_OPERATORS_FOR_FLAGS(SingleApplication::Options)
+Q_DECLARE_OPERATORS_FOR_FLAGS(SINGLEAPPLICATION_CLASS::Options)
 
-#endif // SINGLE_APPLICATION_H
+#endif // @SINGLEAPPLICATION_CLASS@
diff --git a/singleapplication.pc.cmake b/singleapplication.pc.cmake
new file mode 100644
index 0000000..c6651d1
--- /dev/null
+++ b/singleapplication.pc.cmake
@@ -0,0 +1,10 @@
+prefix=@CMAKE_INSTALL_PREFIX@
+exec_prefix=@CMAKE_INSTALL_PREFIX@
+libdir=@LIB_INSTALL_DIR@
+includedir=@INCLUDE_INSTALL_DIR@
+
+Name: @SINGLEAPPLICATION_NAME@
+Description: Library to detect and communicate with running instances of an application
+Version: @SINGLEAPPLICATION_VERSION_PACKAGE@
+Libs: -L${libdir} -l@SINGLEAPPLICATION_NAME@
+Cflags: -I${includedir}
diff --git a/singleapplication_p.cpp b/singleapplication_p.cpp
index 8eb49ab..2cb818c 100644
--- a/singleapplication_p.cpp
+++ b/singleapplication_p.cpp
@@ -39,7 +39,6 @@
 #include <QtNetwork/QLocalServer>
 #include <QtNetwork/QLocalSocket>
 
-#include "singleapplication.h"
 #include "singleapplication_p.h"
 
 #ifdef Q_OS_UNIX
@@ -53,7 +52,7 @@
     #include <lmcons.h>
 #endif
 
-SingleApplicationPrivate::SingleApplicationPrivate( SingleApplication *q_ptr )
+SingleApplicationPrivate::SingleApplicationPrivate( SINGLEAPPLICATION_CLASS *q_ptr )
     : q_ptr( q_ptr )
 {
     server = nullptr;
@@ -109,24 +108,24 @@ void SingleApplicationPrivate::genBlockServerName()
 {
     QCryptographicHash appData( QCryptographicHash::Sha256 );
     appData.addData( "SingleApplication", 17 );
-    appData.addData( SingleApplication::app_t::applicationName().toUtf8() );
-    appData.addData( SingleApplication::app_t::organizationName().toUtf8() );
-    appData.addData( SingleApplication::app_t::organizationDomain().toUtf8() );
+    appData.addData( SINGLEAPPLICATION_CLASS::app_t::applicationName().toUtf8() );
+    appData.addData( SINGLEAPPLICATION_CLASS::app_t::organizationName().toUtf8() );
+    appData.addData( SINGLEAPPLICATION_CLASS::app_t::organizationDomain().toUtf8() );
 
-    if( ! (options & SingleApplication::Mode::ExcludeAppVersion) ) {
-        appData.addData( SingleApplication::app_t::applicationVersion().toUtf8() );
+    if( ! (options & SINGLEAPPLICATION_CLASS::Mode::ExcludeAppVersion) ) {
+        appData.addData( SINGLEAPPLICATION_CLASS::app_t::applicationVersion().toUtf8() );
     }
 
-    if( ! (options & SingleApplication::Mode::ExcludeAppPath) ) {
+    if( ! (options & SINGLEAPPLICATION_CLASS::Mode::ExcludeAppPath) ) {
 #ifdef Q_OS_WIN
-        appData.addData( SingleApplication::app_t::applicationFilePath().toLower().toUtf8() );
+        appData.addData( SINGLEAPPLICATION_CLASS::app_t::applicationFilePath().toLower().toUtf8() );
 #else
-        appData.addData( SingleApplication::app_t::applicationFilePath().toUtf8() );
+        appData.addData( SINGLEAPPLICATION_CLASS::app_t::applicationFilePath().toUtf8() );
 #endif
     }
 
     // User level block requires a user specific data in the hash
-    if( options & SingleApplication::Mode::User ) {
+    if( options & SINGLEAPPLICATION_CLASS::Mode::User ) {
         appData.addData( getUsername() );
     }
 
@@ -147,7 +146,7 @@ void SingleApplicationPrivate::initializeMemoryBlock()
 
 void SingleApplicationPrivate::startPrimary()
 {
-    Q_Q(SingleApplication);
+    Q_Q(SINGLEAPPLICATION_CLASS);
 
     // Successful creation means that no main process exists
     // So we start a QLocalServer to listen for connections
@@ -156,7 +155,7 @@ void SingleApplicationPrivate::startPrimary()
 
     // Restrict access to the socket according to the
     // SingleApplication::Mode::User flag on User level or no restrictions
-    if( options & SingleApplication::Mode::User ) {
+    if( options & SINGLEAPPLICATION_CLASS::Mode::User ) {
       server->setSocketOptions( QLocalServer::UserAccessOption );
     } else {
       server->setSocketOptions( QLocalServer::WorldAccessOption );
@@ -345,7 +344,7 @@ void SingleApplicationPrivate::readInitMessageHeader( QLocalSocket *sock )
 
 void SingleApplicationPrivate::readInitMessageBody( QLocalSocket *sock )
 {
-    Q_Q(SingleApplication);
+    Q_Q(SINGLEAPPLICATION_CLASS);
 
     if (!connectionMap.contains( sock )) {
         return;
@@ -398,7 +397,7 @@ void SingleApplicationPrivate::readInitMessageBody( QLocalSocket *sock )
 
     if( connectionType == NewInstance ||
         ( connectionType == SecondaryInstance &&
-          options & SingleApplication::Mode::SecondaryNotification ) )
+          options & SINGLEAPPLICATION_CLASS::Mode::SecondaryNotification ) )
     {
         Q_EMIT q->instanceStarted();
     }
@@ -410,7 +409,7 @@ void SingleApplicationPrivate::readInitMessageBody( QLocalSocket *sock )
 
 void SingleApplicationPrivate::slotDataAvailable( QLocalSocket *dataSocket, quint32 instanceId )
 {
-    Q_Q(SingleApplication);
+    Q_Q(SINGLEAPPLICATION_CLASS);
     Q_EMIT q->receivedMessage( instanceId, dataSocket->readAll() );
 }
 
diff --git a/singleapplication_p.h b/singleapplication_p.h.in
similarity index 92%
rename from singleapplication_p.h
rename to singleapplication_p.h.in
index 5161411..0fc6e78 100644
--- a/singleapplication_p.h
+++ b/singleapplication_p.h.in
@@ -35,7 +35,7 @@
 #include <QtCore/QSharedMemory>
 #include <QtNetwork/QLocalServer>
 #include <QtNetwork/QLocalSocket>
-#include "singleapplication.h"
+#include "@SINGLEAPPLICATION_NAME@.h"
 
 struct InstancesInfo {
     bool primary;
@@ -67,9 +67,9 @@ Q_OBJECT
         StageBody = 1,
         StageConnected = 2,
     };
-    Q_DECLARE_PUBLIC(SingleApplication)
+    Q_DECLARE_PUBLIC(SINGLEAPPLICATION_CLASS)
 
-    SingleApplicationPrivate( SingleApplication *q_ptr );
+    SingleApplicationPrivate( SINGLEAPPLICATION_CLASS *q_ptr );
      ~SingleApplicationPrivate();
 
     QByteArray getUsername();
@@ -84,13 +84,13 @@ Q_OBJECT
     void readInitMessageHeader(QLocalSocket *socket);
     void readInitMessageBody(QLocalSocket *socket);
 
-    SingleApplication *q_ptr;
+    SINGLEAPPLICATION_CLASS *q_ptr;
     QSharedMemory *memory;
     QLocalSocket *socket;
     QLocalServer *server;
     quint32 instanceNumber;
     QString blockServerName;
-    SingleApplication::Options options;
+    SINGLEAPPLICATION_CLASS::Options options;
     QMap<QLocalSocket*, ConnectionInfo> connectionMap;
 
 public Q_SLOTS:
